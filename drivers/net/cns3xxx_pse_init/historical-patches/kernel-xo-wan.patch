diff -urN kernel/linux/drivers/net/cns3xxx_pse_init/Kconfig linux/drivers/net/cns3xxx_pse_init/Kconfig
--- kernel/linux/drivers/net/cns3xxx_pse_init/Kconfig	2011-07-07 09:17:23.000000000 +0000
+++ kernel/linux/drivers/net/cns3xxx_pse_init/Kconfig	2012-05-02 06:03:48.000000000 +0000
@@ -104,6 +104,11 @@
 	  This configureation connect MAC0 to Vitesse 7395 
           And run at 802.1p mode. WAN port vid is 2, LAN port vid is 3
 
+config XO
+	bool "XO Board"
+	help
+	  MAC1 and MAC2 connect to Vitesse 8601 gigabit ethernet transceivers.
+
 endchoice
 
 config BCM53115
diff -urN kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.c linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.c
--- kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.c	2011-07-20 09:35:07.000000000 +0000
+++ kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.c	2012-05-23 07:24:38.000000000 +0000
@@ -1594,8 +1594,8 @@
 
 	mac_port_config = SWITCH_REG_VALUE(mac_addr[mac_port]);
 
-	//cns3xxx_txc_dly(mac_port, 2);
-	//cns3xxx_rxc_dly(mac_port, 2);
+	cns3xxx_txc_dly(mac_port, 2);
+	cns3xxx_rxc_dly(mac_port, 2);
 	//SLK_SKEW_CTRL_REG 
 #if 1
 
@@ -1668,6 +1668,18 @@
 
 	cns3xxx_mdc_mdio_disable(0);
 	cns3xxx_phy_reset(phy_addr);
+
+	if(phy_id == PHYID_VSC8601) { 
+		// enable extended PHY reg
+		cns3xxx_write_phy(phy_addr, 31, 1);
+
+		// LED mode (extended)
+		cns3xxx_write_phy(phy_addr, 17, 0x518);
+		cns3xxx_write_phy(phy_addr, 16, 0x316a);
+
+		// disable extended PHY reg
+		cns3xxx_write_phy(phy_addr, 31, 0);
+	}
 	if(phy_id == PHYID_AR8021) { //The AR8021 reset will take a long time to finish AN...
 		while(1) {
 			cns3xxx_read_phy(phy_addr, 0, &phy_data);
@@ -2887,6 +2899,11 @@
 		// rgmii_phy, giga mode
 		general_init_phy(mac_port, phy_addr, phy_id, 1, 1);
 		break;
+	case PHYID_VSC8601:
+		printk("Initialize VSC8601\n");
+		// rgmii_phy, giga mode
+		general_init_phy(mac_port, phy_addr, phy_id, 1, 1);
+		break;
 	default:
 		printk("unknown phy id: %x\n", phy_id);
 		return 1;
@@ -3934,3 +3951,50 @@
 #endif // CONFIG_RTL8367_ONE_LEG
 
 
+void vsc7385_init_mac(u8 mac_port)
+{
+    u32 mac_port_config = 0;
+    u8 mac_addr[]={0x0c, 0x10, 0x18};
+    u8 tx = 0, rx = 0;
+
+    cns3xxx_enable_mac_clock(mac_port, 1);
+    cns3xxx_phy_auto_polling_enable(mac_port, 0);
+
+    mac_port_config = SWITCH_REG_VALUE(mac_addr[mac_port]);
+
+    /* enable GMII, MII, reverse MII */
+    mac_port_config &= (~(1 << 15));
+
+    /* enable RGMII */
+    mac_port_config |= (1 << 15);
+
+    /* disable GIGA mode */
+    mac_port_config &= (~(1<<16));
+
+    /* enable GIGA mode */
+    mac_port_config |= (1<<16);
+
+    /* disable PHY's AN */
+    mac_port_config &= (~(0x1 << 7));
+
+    /* force 1000Mbps */
+    mac_port_config &= (~(0x3 << 8));
+    mac_port_config |= (0x2 << 8);
+
+    /* force duplex */
+    mac_port_config |= (0x1 << 10);
+
+    /* TX flow control off */
+    mac_port_config &= ~(0x1 << 12);
+
+    /* RX flow control off */
+    mac_port_config &= ~(0x1 << 11);
+
+    /* Turn off GSW_PORT_TX_CHECK_EN_BIT */
+    mac_port_config &= (~(0x1 << 13));
+
+    /* Turn on GSW_PORT_TX_CHECK_EN_BIT */
+    mac_port_config |= (0x1 << 13);
+
+    SWITCH_REG_VALUE(mac_addr[mac_port]) = mac_port_config;
+}
diff -urN kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.h linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.h
--- kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.h	2011-07-07 09:17:23.000000000 +0000
+++ kernel/linux/drivers/net/cns3xxx_pse_init/cns3xxx_phy.h	2012-05-02 05:49:41.000000000 +0000
@@ -103,5 +103,6 @@
 #define PHYID_RTL8211	0x001C
 #define PHYID_IP1001	0x0243
 #define PHYID_AR8021	0x004D
+#define PHYID_VSC8601	0x0007
 
 #endif // end #ifndef CNS3XXX_PHY_H
diff -urN kernel/linux/drivers/net/cns3xxx_pse_init/pse_init.c linux/drivers/net/cns3xxx_pse_init/pse_init.c
--- kernel/linux/drivers/net/cns3xxx_pse_init/pse_init.c	2011-07-20 09:35:07.000000000 +0000
+++ kernel/linux/drivers/net/cns3xxx_pse_init/pse_init.c	2012-05-02 06:11:28.000000000 +0000
@@ -42,6 +42,10 @@
 #include "vb2.h"
 #endif
 
+#ifdef CONFIG_XO
+#include "xo.h"
+#endif
+
 #ifdef CONFIG_RTL8211
 #include "rtl8211.h"
 #endif
@@ -322,6 +326,13 @@
 	//u32 cfg_reg = 0;
 	//u32 reg_config = 0;
 
+#ifdef CONFIG_XO
+	// use GPIO pins to enable PHYs
+	unsigned int output_high_mask = 1<<13 | 1<<12 | 1<<9 | 1<<8;
+	GPIOA_REG_VALUE(8) = output_high_mask;    /* direction = out */
+	GPIOA_REG_VALUE(0x10) = output_high_mask; /* value = high */
+#endif
+
 #ifdef CONFIG_SILICON
 
 	GPIOB_PIN_EN_REG |= (1 << 14); //enable GMII2_CRS
@@ -385,9 +396,9 @@
 
 
 #if 1
-	//printk("do cns3xxx gsw memory test\n");
+	printk("do cns3xxx gsw memory test\n");
 	while (((SRAM_TEST_REG >> 20) & 1) == 0);
-	//printk("cns3xxx gsw memory test is complete\n");
+	printk("cns3xxx gsw memory test is complete\n");
 
 #endif
 
diff -urN kernel/linux/drivers/net/cns3xxx_pse_init/xo.h linux/drivers/net/cns3xxx_pse_init/xo.h
--- kernel/linux/drivers/net/cns3xxx_pse_init/xo.h	1970-01-01 00:00:00.000000000 +0000
+++ kernel/linux/drivers/net/cns3xxx_pse_init/xo.h	2012-05-23 07:24:26.000000000 +0000
@@ -0,0 +1,422 @@
+/*******************************************************************************
+ *
+ *   Copyright (c) 2009 Cavium Networks 
+ *
+ *   This program is free software; you can redistribute it and/or modify it
+ *   under the terms of the GNU General Public License as published by the Free
+ *   Software Foundation; either version 2 of the License, or (at your option)
+ *   any later version.
+ *
+ *   This program is distributed in the hope that it will be useful, but WITHOUT
+ *   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
+ *   FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for
+ *   more details.
+ *
+ *   You should have received a copy of the GNU General Public License along with
+ *   this program; if not, write to the Free Software Foundation, Inc., 59
+ *   Temple Place - Suite 330, Boston, MA  02111-1307, USA.
+ *
+ *   The full GNU General Public License is included in this distribution in the
+ *   file called LICENSE.
+ *
+ ********************************************************************************/
+
+// This macro or function divide two part, 
+// one is initial state, another is in netdev open (ifconfig up) function.
+
+#ifndef  XO_H
+#define  XO_H
+
+#include <linux/types.h>
+
+#include "cns3xxx.h"
+#include "cns3xxx_phy.h"
+
+#ifdef CONFIG_XO
+
+// init phy or switch chip
+#define INIT_PORT0_PHY probe_phy(0, 1);
+#define INIT_PORT1_PHY probe_phy(1, 2);
+#define INIT_PORT2_PHY 
+
+// configure mac0/mac1 register
+void vsc7385_init_mac(u8 mac_port);
+#define INIT_PORT0_MAC 
+#define INIT_PORT1_MAC
+#define INIT_PORT2_MAC vsc7385_init_mac(2);
+
+#define PORT0_LINK_DOWN cns3xxx_std_phy_power_down(1, 1);
+#define PORT0_LINK_UP cns3xxx_std_phy_power_down(1, 0);
+
+#define PORT1_LINK_DOWN cns3xxx_std_phy_power_down(2, 1);
+#define PORT1_LINK_UP cns3xxx_std_phy_power_down(2, 0);
+
+#define PORT2_LINK_DOWN 
+#define PORT2_LINK_UP 
+
+#define MODEL "XO1 board"
+
+static int rc_port0 = 0; // rc means reference counting, determine port open/close.
+
+//#define PRINT_INFO printk
+
+// enable port
+// link down
+static inline void open_port0(void)
+{
+        if (rc_port0 == 0) {
+		enable_port(0, 1);
+		//PRINT_INFO("open mac port 0\n");
+		// link up
+		PORT0_LINK_UP
+	} else {
+		//PRINT_INFO("port 0 already open\n");
+	}
+	++rc_port0;
+}
+
+static inline void close_port0(void)
+{
+	--rc_port0;
+        if (rc_port0 == 0) {
+		// link down
+		PORT0_LINK_DOWN
+		enable_port(0, 0);
+       		//PRINT_INFO("close mac port 0\n");
+	}
+}
+
+static inline void open_port1(void)
+{
+
+	enable_port(1, 1);
+	//PRINT_INFO("open mac port 1\n");
+	// link up
+	PORT1_LINK_UP
+}
+
+static inline void close_port1(void)
+{
+	enable_port(1, 0);
+	//PRINT_INFO("close mac port 1\n");
+	// link down
+	PORT1_LINK_DOWN
+}
+
+static inline void open_port2(void)
+{
+	enable_port(2, 1);
+	//PRINT_INFO("open mac port 2\n");
+	// link up
+	PORT2_LINK_UP
+}
+
+static inline void close_port2(void)
+{
+	enable_port(2, 0);
+	//PRINT_INFO("close mac port 2\n");
+	// link down
+	PORT2_LINK_DOWN
+}
+
+#if defined (CONFIG_CNS3XXX_SPPE)
+/* only for PPE PCI-to-WAN fast path */
+static int fp_ref_cnt = 0;
+static inline void open_fp(void)
+{
+	if (!fp_ref_cnt) {
+		fp_ref_cnt++;
+	}
+}
+
+static inline void close_fp(void)
+{
+	if (fp_ref_cnt) {
+		fp_ref_cnt--;
+	}
+}
+#endif
+
+#if 0
+static u8 my_vlan0_mac[] = {0x00, 0x11, 0x22, 0x33, 0x55, 0x00};
+static u8 my_vlan1_mac[] = {0x00, 0x11, 0x22, 0x33, 0x55, 0x11};
+static u8 my_vlan2_mac[] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x70};
+static u8 my_vlan3_mac[] = {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x80};
+#endif
+
+
+#define my_vlan0_mac {0x00, 0x11, 0x22, 0x33, 0x55, 0x00}
+#define my_vlan1_mac {0x00, 0x11, 0x22, 0x33, 0x55, 0x11}
+#define my_vlan2_mac {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x70}
+#define my_vlan3_mac {0x00, 0x11, 0xbb, 0xcc, 0xdd, 0x80}
+
+
+// CNS3XXX_NIC_MODE_8021Q, CNS3XXX_NON_NIC_MODE_8021Q, CNS3XXX_VLAN_BASE_MODE and
+// CNS3XXX_PORT_BASE_MODE, only one macro can be defined
+
+#if defined(CONFIG_VLAN_8021Q) || defined(CONFIG_VLAN_8021Q_MODULE)
+	//#define CNS3XXX_NIC_MODE_8021Q
+	#ifndef CNS3XXX_NIC_MODE_8021Q
+		#define CNS3XXX_NON_NIC_MODE_8021Q
+	#endif
+#else
+	//#define CNS3XXX_VLAN_BASE_MODE
+	#define CNS3XXX_PORT_BASE_MODE
+#endif
+
+//#define CNS3XXX_PORT_BASE_MODE
+//
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+
+#define PORT0_PVID 50
+#define PORT1_PVID 60
+#define PORT2_PVID 70
+#define CPU_PVID 80
+
+#define CONFIG_CNS3XXX_PORT_BASE
+
+VLANTableEntry cpu_vlan_table_entry = {0, 1, CPU_PVID, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}; 
+
+VLANTableEntry vlan_table_entry[] = 
+{
+	// vlan_index; valid; vid; wan_side; etag_pmap; mb_pmap; *my_mac;
+	#if 0
+	{1, 1, PORT0_PVID, 0, 0, MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{2, 1, PORT1_PVID, 0, 0, MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac},
+	{3, 1, PORT2_PVID, 1, 0, MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac},
+	#endif
+
+	{1, 1, PORT0_PVID, 0, CPU_PORT_PMAP, MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{2, 1, PORT1_PVID, 0, CPU_PORT_PMAP, MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac},
+	{3, 1, PORT2_PVID, 0, CPU_PORT_PMAP, MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac},
+	//{2, 1, 4, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}, // for cpu
+};
+
+ARLTableEntry arl_table_entry[] = 
+{
+	// vid; pmap; *mac; age_field; vlan_mac ; filter
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	//{CPU_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+	//{PORT0_PVID, MAC_PORT0_PMAP, my_vlan8_mac, 7, 0, 0},
+	//{PORT0_PVID, MAC_PORT0_PMAP, my_vlan9_mac, 7, 0, 0},
+	//{CPU_PVID, 0x4, my_vlan2_mac, 7, 1, 0},
+	//{CPU_PVID, MAC_PORT2_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+NetDevicePriv net_device_prive[]= {
+	/*  pmap, is_wan, s-tag, vlan_tag or pvid, rx_func_ptr, tx_func_ptr, open_ptr, close_ptr, which port, mac, VLANTableEntry, ARLTableEntry, NICSetting, netdev s-tag, name */
+	{MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base, tx_port_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac, &vlan_table_entry[0], &arl_table_entry[0], 0, 0},   // eth0 
+	{MAC_PORT1_PMAP, 0, 2, PORT1_NETDEV_INDEX, rx_port_base, tx_port_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac, &vlan_table_entry[1], &arl_table_entry[1], 0, 0},   // eth1 
+	{MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base, tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,  &vlan_table_entry[2], &arl_table_entry[2], 0, 0}   // eth2
+#if defined (CONFIG_CNS3XXX_SPPE)
+	,{CPU_PORT_PMAP, 0, 1, FP_NETDEV_INDEX, NULL, fp_port_base,
+		open_fp, close_fp, CPU_PORT, my_vlan3_mac, &cpu_vlan_table_entry,
+		0, 0, "fp"}
+#endif 
+					 };
+
+#endif // CNS3XXX_PORT_BASE_MODE
+
+#ifdef CNS3XXX_PORT_BASE_MODE
+
+#define PORT0_PVID 0x1
+#define PORT1_PVID 0x2
+#define PORT2_PVID 3
+#define CPU_PVID 5
+
+#define CONFIG_CNS3XXX_PORT_BASE
+
+VLANTableEntry cpu_vlan_table_entry = {0, 1, CPU_PVID, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}; 
+
+VLANTableEntry vlan_table_entry[] = 
+{
+	// vlan_index; valid; vid; wan_side; etag_pmap; mb_pmap; *my_mac;
+	//{0, 1, 1, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{1, 1, PORT0_PVID, 0, 0, MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{2, 1, PORT1_PVID, 0, 0, MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac},
+	{3, 1, PORT2_PVID, 1, 0, MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac},
+	//{2, 1, 4, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}, // for cpu
+};
+
+ARLTableEntry arl_table_entry[] = 
+{
+	// vid; pmap; *mac; age_field; vlan_mac ; filter
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	//{CPU_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+	//{PORT0_PVID, MAC_PORT0_PMAP, my_vlan8_mac, 7, 0, 0},
+	//{PORT0_PVID, MAC_PORT0_PMAP, my_vlan9_mac, 7, 0, 0},
+	//{CPU_PVID, 0x4, my_vlan2_mac, 7, 1, 0},
+	//{CPU_PVID, MAC_PORT2_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+NetDevicePriv net_device_prive[]= {
+	/*  pmap, is_wan, s-tag, vlan_tag or pvid, rx_func_ptr, tx_func_ptr, open_ptr, close_ptr, which port, mac, VLANTableEntry, ARLTableEntry, NICSetting, netdev s-tag, name */
+	{MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base, tx_port_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac, &vlan_table_entry[0], &arl_table_entry[0], 0, 0},   // eth0 
+	{MAC_PORT1_PMAP, 0, 2, PORT1_NETDEV_INDEX, rx_port_base, tx_port_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac, &vlan_table_entry[1], &arl_table_entry[1], 0, 0},   // eth1 
+	{MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base, tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,  &vlan_table_entry[2], &arl_table_entry[2], 0, 0}   // eth2 
+					 };
+
+#endif // CNS3XXX_PORT_BASE_MODE
+
+#ifdef CNS3XXX_NIC_MODE_8021Q
+//#error  "8021Q"
+#define PORT0_PVID 1
+#define PORT1_PVID 2
+#define PORT2_PVID 9
+#define CPU_PVID 5
+
+#define CONFIG_CNS3XXX_PORT_BASE
+//#define CONFIG_CNS3XXX_VLAN_BASE
+//#define CONFIG_HAVE_VLAN_TAG
+
+VLANTableEntry cpu_vlan_table_entry = {0, 1, CPU_PVID, 0, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}; // for cpu
+
+VLANTableEntry vlan_table_entry[] = 
+{
+	// vlan_index; valid; vid; wan_side; etag_pmap; mb_pmap; *my_mac;C_PORT2_PMAP
+	{1, 1, PORT0_PVID, 1, MAC_PORT0_PMAP|CPU_PORT_PMAP, MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{2, 1, PORT1_PVID, 0, MAC_PORT1_PMAP|CPU_PORT_PMAP, MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac},
+	{3, 1, PORT2_PVID, 1, MAC_PORT2_PMAP|CPU_PORT_PMAP, MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac},
+};
+
+ARLTableEntry arl_table_entry[] = 
+{
+	// vid; pmap; *mac; age_field; vlan_mac ; filter
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+
+// if used 8021Q, use PORT0_NETDEV_INDEX, don't use VID
+NetDevicePriv net_device_prive[]= {
+	{MAC_PORT0_PMAP, 0, 1, PORT0_NETDEV_INDEX, rx_port_base, tx_port_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac, &vlan_table_entry[0], &arl_table_entry[0], 0, 0},   // eth0 
+	{MAC_PORT1_PMAP, 0, 0, PORT1_NETDEV_INDEX, rx_port_base, tx_port_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac, &vlan_table_entry[1], &arl_table_entry[1], 0, 0},   // eth1 
+	{MAC_PORT2_PMAP, 1, 3, PORT2_NETDEV_INDEX, rx_port_base, tx_port_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,  &vlan_table_entry[2], &arl_table_entry[2], 0, 0}   // eth2 
+					  };
+#endif // CNS3XXX_NIC_MODE_8021Q
+
+#ifdef CNS3XXX_VLAN_BASE_MODE
+//#error  "vlan_base"
+// vlan configuration
+
+#define PORT0_PVID 1
+#define PORT1_PVID 2
+#define PORT2_PVID 3
+#define CPU_PVID 5
+#define CONFIG_CNS3XXX_VLAN_BASE
+#define CONFIG_HAVE_VLAN_TAG
+
+VLANTableEntry cpu_vlan_table_entry = {0, 1, CPU_PVID, 0, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, MAC_PORT0_PMAP | MAC_PORT1_PMAP | MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan3_mac}; // for cpu
+
+VLANTableEntry vlan_table_entry[] = 
+{
+	// vlan_index; valid; vid; wan_side; etag_pmap; mb_pmap; *my_mac;
+	{1, 1, PORT0_PVID, 0, MAC_PORT0_PMAP | CPU_PORT_PMAP, MAC_PORT0_PMAP | CPU_PORT_PMAP, my_vlan0_mac},
+	{2, 1, PORT1_PVID, 0, MAC_PORT1_PMAP | CPU_PORT_PMAP, MAC_PORT1_PMAP | CPU_PORT_PMAP, my_vlan1_mac},
+	{3, 1, PORT2_PVID, 1, MAC_PORT2_PMAP | CPU_PORT_PMAP, MAC_PORT2_PMAP | CPU_PORT_PMAP, my_vlan2_mac},
+};
+
+ARLTableEntry arl_table_entry[] = 
+{
+	// vid; pmap; *mac; age_field; vlan_mac ; filter
+	{PORT0_PVID, CPU_PORT_PMAP, my_vlan0_mac, 7, 1, 0},
+	{PORT1_PVID, CPU_PORT_PMAP, my_vlan1_mac, 7, 1, 0},
+	{PORT2_PVID, CPU_PORT_PMAP, my_vlan2_mac, 7, 1, 0},
+};
+
+NetDevicePriv net_device_prive[]= {
+	/*  pmap, is_wan, gid, vlan_tag or pvid, rx_func_ptr, tx_func_ptr, open_ptr, close_ptr, which port, mac, VLANTableEntry, ARLTableEntry, NICSetting, netdev name */
+	{MAC_PORT0_PMAP, 0, 1, PORT0_PVID, rx_port_base, tx_vlan_base, open_port0, close_port0, MAC_PORT0, my_vlan0_mac, &vlan_table_entry[0], &arl_table_entry[0], 0, 0},   // eth0 
+	{MAC_PORT1_PMAP, 0, 0, PORT1_PVID, rx_port_base, tx_vlan_base, open_port1, close_port1, MAC_PORT1, my_vlan1_mac, &vlan_table_entry[1], &arl_table_entry[1], 0, 0},   // eth1 
+	{MAC_PORT2_PMAP, 1, 3, PORT2_PVID, rx_port_base, tx_vlan_base, open_port2, close_port2, MAC_PORT2, my_vlan2_mac,  &vlan_table_entry[2], &arl_table_entry[2], 0, 0}   // eth2 
+					 };
+#endif // CNS3XXX_VLAN_BASE_MODE
+
+
+
+int is_config_cns3xxx_port_base(void)
+{
+#ifdef CONFIG_CNS3XXX_PORT_BASE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_cns3xxx_port_base);
+
+int is_config_cns3xxx_vlan_base(void)
+{
+#ifdef CONFIG_CNS3XXX_VLAN_BASE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_cns3xxx_vlan_base);
+
+int is_config_have_vlan_tag(void)
+{
+#ifdef CONFIG_HAVE_VLAN_TAG
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_config_have_vlan_tag);
+
+
+int is_cns3xxx_nic_mode_8021q(void)
+{
+#ifdef CNS3XXX_NIC_MODE_8021Q
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_nic_mode_8021q);
+
+int is_cns3xxx_non_nic_mode_8021q(void)
+{
+#ifdef CNS3XXX_NON_NIC_MODE_8021Q
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_non_nic_mode_8021q);
+
+int is_cns3xxx_vlan_base_mode(void)
+{
+#ifdef CNS3XXX_VLAN_BASE_MODE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_vlan_base_mode);
+
+int is_cns3xxx_port_base_mode(void)
+{
+#ifdef CNS3XXX_PORT_BASE_MODE
+	return 1;
+#else
+	return 0;
+#endif
+}
+EXPORT_SYMBOL_GPL(is_cns3xxx_port_base_mode);
+
+int num_net_dev_priv = sizeof(net_device_prive)/sizeof(NetDevicePriv);
+EXPORT_SYMBOL_GPL(num_net_dev_priv);
+
+EXPORT_SYMBOL_GPL(cpu_vlan_table_entry);
+EXPORT_SYMBOL_GPL(vlan_table_entry);
+EXPORT_SYMBOL_GPL(arl_table_entry);
+EXPORT_SYMBOL_GPL(net_device_prive);
+
+#endif // CONFIG_XO
+#endif // XO_H
